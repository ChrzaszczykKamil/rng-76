<html>
    <head>
        <title>Fallout 76 Drop Chances</title>
        <style>
            * {
                font-family: sans-serif;
                font-size: 20px;
            }
            td {
                padding: 2px;
            }
            
            table.infoTable {
               border: 1px solid black;
               border-collapse: collapse;
            }
            table.infoTable td {
               border: 1px solid black;
            }
        </style>
        <meta name="keywords" content="Fallout,Fallout 76,RNG,Random,Chances,Leveled,Leveled List,LVLI,Datamine">
    </head>
    <body>
        <center>
            <span style="font-size: 36px; font-weight: bold;">Fallout 76 Drop Chances (0.0.6)</span><br/>
            <br/>
            <br/>
            Select version:
            <select id='versionselect'>
                <option value='P19' selected='selected'>Update 19: 19th May, 2020 (latest)</option>
            </select>
            &nbsp;&nbsp;
            <button id='loadversion'>Load</button>
            <!-- &nbsp; (Note that the site downloads up to 3MB of data for the selected version!) -->
            <hr>
            <table>
                <tr>
                    <td id='listsearchtip'>
                    </td>
                    <td>
                        <input id='listsearchterm' name='listsearchterm' type='text' style='width: 300px;' value='' autocomplete="on">&nbsp;<button id='listsearchbtn'>Find</button>
                    </td>
                    <td style='width: 30px;'></td>
                    <td id='itemsearchtip'>

                    </td>
                    <td>
                        <input id='itemsearchterm' name='itemsearchterm' type='text' style='width: 300px;' value='' autocomplete="on">&nbsp;<button id='itemsearchbtn'>Find</button>
                    </td>
                    <td style='padding-left: 30px'>
                        <button id='clearResults'>Clear results</button>
                    </td>
                </tr>
                <tr>
                    <td colspan='5' style='text-align: center;'>
                        <input type='checkbox' id='IncludeATX' checked><label for='IncludeATX'>Include Atom Shop</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='IncludeCut'><label for='IncludeCut'>Include cut content</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='IncludeDebug'><label for='IncludeDebug'>Include debug content</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='SortByEditorID' checked><label for='SortByEditorID'>Sort by EditorID</label>&nbsp;&nbsp;&nbsp;
                        <input type='checkbox' id='Coalesce' checked><label for='Coalesce'>Coalesce duplicate entries</label>
                    </td>
                </tr>
            </table>
            <hr>
            <table id='searchresults'>

            </table>
            <hr>
            <a id='tableLink' href="#" target="_blank" style='display: none;'>Link to the selected setup below:</a><br/><br/><br/>
            <span id='settingstoggle' style='border: 1px solid black; font-family: monospace; cursor: pointer;'>&nbsp;-&nbsp;</span>&nbsp;<b>List settings:</b>
            <table id='settings' style='border-collapse: collapse; margin-top: 5px;'>
                <tr>

                    <td style='border: 1px solid gray; vertical-align: top;'>
                        <div id="settingsCheckboxes" style='overflow-y: scroll; height: 150px;'>
                        </div>
                    </td>
                    <td style='border: 1px solid gray; vertical-align: top;'>
                        <div id="settingsComboboxes" style='overflow-y: scroll; height: 150px;'>
                        </div>
                    </td>
                    <td style='border: 1px solid gray; vertical-align: top;'>
                        <div id="settingsGlobals" style='overflow-y: scroll; height: 150px;'>
                        </div>
                    </td>
                </tr>
            </table>
            
            <table id='listtable' style='margin-top: 15px;'>

            </table>
        </center>
        <script>
            // property key is the FormID, property value is the Group string (4chars) concatenated with the EditorID
            var edids = {};
            // property key is the FormID, property value is the global float
            var globals = {};
            // property key is the FormID, property value is the leveled list object
            var leveledLists = {};
            // property key is the FormID, property value is an array of objects with the form { "x": 0, "y" : 0 }
            var curves = {};

            var downloadDone = 0;

            // the currently shown chain of formids
            var currentFormIDs = [];

            // up to how many list items to consider for the formula evaluations
            var formulaLimit = 20;
            // how many runs to do for the monte-carlo simulation
            var monteCarloCount = 1 << 20;

            // if a number > 0 but less than epsilon, it is treated as zero.
            var epsilon = 0.000001;

            function allDownloaded() {
                document.getElementById("loadversion").disabled = false;
                // TODO 
                console.log(Object.keys(edids).length);
                console.log(Object.keys(globals).length);
                console.log(Object.keys(leveledLists).length);
                console.log(Object.keys(curves).length);

                // find cross references
                for (var listID in leveledLists) {

                    var lvli = leveledLists[listID];

                    if (lvli.Entries !== undefined) {
                        for (var entry of lvli.Entries) {

                            var refList = leveledLists[entry.Object];

                            if (refList !== undefined) {
                                if (refList.Parents === undefined) {
                                    refList.Parents = [];
                                }
                                if (!refList.Parents.includes(listID)) {
                                    refList.Parents.push(listID);
                                }
                            }
                        }
                    }
                }

                var q = location.search;
                if (q.includes("formids=")) {
                    var idx = q.indexOf("formids=");
                    var ids = q.substr(idx + 8).split("-");
                    showChain(ids);
                }
            }

            function loadScript(src, callback) {
                var r = false;
                var s = document.createElement('script');
                s.type = 'text/javascript';
                s.src = src;
                s.onload = s.onreadystatechange = function() {
                    //console.log( this.readyState ); //uncomment this line to see which ready states are called.
                    if ( !r && (!this.readyState || this.readyState == 'complete') ) {
                        r = true;
                        callback(s);
                    }
                };
                var t = document.getElementsByTagName('script')[0];
                t.parentNode.insertBefore(s, t);
            }

            function doLoad() {
                document.getElementById("loadversion").disabled = true;

                var versionSelect = document.getElementById("versionselect");
                if (versionSelect.selectedIndex >= 0) {
                    downloadDone = 4;
                    var patchPrefix = 
                        // "https://akarnokd.github.com/rng-76/" +
                        versionSelect.options[versionSelect.selectedIndex].value + "_";

                    loadScript(patchPrefix + "SeventySix_EDIDs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                    loadScript(patchPrefix + "SeventySix_GLOBs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                    loadScript(patchPrefix + "SeventySix_LVLIs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                    loadScript(patchPrefix + "SeventySix_CURVs.js", node => {
                        if (--downloadDone == 0) {
                           allDownloaded();
                        }
                    });
                }
            }


            document.getElementById("loadversion").onclick = doLoad;

            var infoMap = new Map();
            infoMap.set("ListSearch", 
                "Enter the FormID (leading zeros can be omitted) or Editor ID of the leveled list to find."
                + "<br>Use * to indicate a wildcard (e.g., *Fasnacht*)."
                + "<br>Use commas to list alternative options."
                + "<br>Spaces and capitalization are ignored."
            );
            infoMap.set("ItemSearch", 
                "Enter the FormID (leading zeros can be omitted) or Editor ID of the item you want to locate in the leveled lists."
                + "<br>Use * to indicate a wildcard (e.g., *Fixer*)."
                + "<br>Use commas to list alternative options."
                + "<br>Spaces and capitalization are ignored."
            );

            // add HTML explanation marker
            function info(name) {
                return "&nbsp;<sup><a href='#' style='font-size: 14; font-weight: bold;' onclick='showinfo(this, \"" + name + "\"); return false;'>Tip</a></sup>";
            }

            // popup for explanation
            function showinfo(target, name) {
                var div = document.getElementById("InfoDiv" + name);
                if (div == null) {
                    var div = document.createElement("div");
                    div.style.border = "1px solid black";
                    div.style.padding = "3px";
                    div.style.position = "absolute";
                    div.style.backgroundColor = "#FFFFD0";
                    div.style.zIndex = 99;
                    div.id = "InfoDiv" + name;
                    var txt = infoMap.get(name);

                    if (txt == null) {
                        txt = "??? " + name + " ???";
                    }
                    txt += "<hr><font style='font-size: 14px'>Click to close.</font>";
                    div.innerHTML = txt;

                    target.parentElement.appendChild(div);
                    div.onclick = function() {
                        target.parentElement.removeChild(div);
                    }
                } else {
                    target.parentElement.removeChild(div);
                }
            }

            document.getElementById("listsearchtip").innerHTML = "Search leveled list " + info("ListSearch");
            document.getElementById("itemsearchtip").innerHTML = "Search item in lists " + info("ItemSearch");

            // paging support
            var searchResults = [];

            function parseSearchText(text) {

                var result = text.split(",");
                for (var i = 0; i < result.length; i++) {
                    // remove spaces
                    var entry = result[i];

                    entry = entry.replace(" ", "");;
                    entry = entry.replace(/\*/g, ".*");
                    entry = entry.replace(/^0+/, "");
                    entry = entry.toLowerCase();

                    result[i] = new RegExp("^" + entry + "$");
                }

                return result;
            }

            function getEditorID(formID) {
                var result = edids[formID];
                if (result !== undefined) {
                    return result.substring(4);
                }
                return "";
            }

            function getGroupID(formID) {
                var result = edids[formID];
                if (result !== undefined) {
                    return result.substring(0, 4);
                }
                return "";
            }

            function createListLink(formID, text) {
                return "<a href='#' onclick='showList(\"" + formID + "\"); return false;'>" + text + "</a>";
            }

            function interpolate(curveTable, x) {
                var first = curveTable[0];
                if (x <= first.x) {
                    return first.y;
                }
                var last = curveTable[curveTable.length - 1];
                if (last <= x) {
                    return last.y;
                }
                for (var i = 0; i < curveTable.length - 1; i++) {
                    var curr = curveTable[i];
                    var next = curveTable[i + 1];

                    if (curr.x <= x && x < next.x) {
                        var step = next.x - curr.x;
                        var raise = next.y - curr.y;

                        var xrate = (x - curr.x) / step;

                        var yrate = curr.y + raise * xrate;

                        return yrate;
                    }
                }
                return NaN;
            }

            function decodeValue(entry, keyDirect, keyGlobal, keyCurve) {
                var curveID = entry[keyCurve];
                var globalID = entry[keyGlobal];
                if (curveID !== undefined) {
                    var curveTable = curves[curveID];
                    if (curveTable !== undefined) {
                        if (globalID !== undefined) {
                            var x = getSettingsValue(globalID);
                            if (x === undefined) {
                                x = globals[globalID];
                            }
                            if (x !== undefined) {
                                var v = interpolate(curveTable, x);                            
                                return {
                                    type: "Curve",
                                    id: curveID,
                                    g: globalID,
                                    x: x,
                                    value: v
                                };
                            }

                            return {
                                type: "Curve",
                                id: curveID,
                                x: globalID,
                                error: "Global value not found"
                            };
                        }
                        return {
                            type: "Curve",
                            id: curveID,
                            error: "Global reference entry missing"
                        }
                    }
                    return {
                        type: "Curve",
                        id: curveID,
                        error: "Curve table not found."
                    }
                }
                if (globalID !== undefined) {
                    var x = getSettingsValue(globalID);
                    if (x === undefined) {
                        x = globals[globalID];
                    }
                    if (x !== undefined) {
                        return {
                            type: "Global",
                            id: globalID,
                            value: x
                        };
                    }
                    return {
                        type: "Global",
                        id: globalID,
                        error: "Global value not found"
                    }
                }

                var direct = entry[keyDirect];
                if (direct === undefined) {
                    direct = 0;
                }

                return {
                    type: "Constant",
                    value: direct
                };
            }

            function createNukaLink(formID) {
                return "<a href='https://nukacrypt.com/database/json/" + formID + "' target='_blank' title='See Nukacrypt data.'>&#x2622;&nbsp;"
                    + getGroupID(formID) + ":" + formID + " &lt;" + getEditorID(formID) + "&gt;"
                    + "</a>";
            }

            function buildConditionEntry(parent, entry, maxCols) {
                if (entry.Conditions !== undefined) {
                    n = parent.rows.length;
                    row = parent.insertRow(n);
                    cll = row.insertCell(row.cells.length);
                    cll.colSpan = maxCols;
                    cll.style.paddingLeft = "60px";

                    var innerTbl = document.createElement("table");
                    innerTbl.style.width = "100%";
                    cll.appendChild(innerTbl);

                    row = innerTbl.insertRow(0);
                    cll = row.insertCell(0);
                    var checkTxt = "";

                    if (evaluateConditions(entry.Conditions)) {
                        checkTxt = "<span style='color: green; font-weight: bold'>[ &#128077; PASS ]</span>";
                    } else {
                        checkTxt = "<span style='color: red; font-weight: bold'>[ &#10060; FAIL ]</span>";
                    }

                    cll.innerHTML = "Conditions (" + entry.Conditions.length + ")&nbsp;&nbsp;&nbsp;" + checkTxt;

                    cll.style.backgroundColor = "#FFC0FF";
                    cll.style.fontWeight = "bold";

                    buildConditionItem(innerTbl, entry);
                }
            }

            function buildConditionItem(innerTbl, entry) {
                var i = 0;
                for (var cond of entry.Conditions) {
                    row = innerTbl.insertRow(innerTbl.rows.length);
                    cll = row.insertCell(0);

                    cll.style.backgroundColor = "E0E0E0";

                    var fn = cond.FunctionName;
                    var txt = "&nbsp;&nbsp;&nbsp;<b>" + fn + "</b>";

                    if (fn === "HasLearnedRecipe"
                        || fn === "GetIsInRegion"
                        || fn === "EditorLocationHasKeyword"
                        || fn === "GetGlobalValue"
                        || fn === "GetQuestCompleted") {
                        txt += "(" + createNukaLink(cond.Param1Ref) + ")";
                    }

                    var operatorKind = (cond.Operator & 0xFF) >> 5;
                    if (operatorKind == 0) {
                        txt += "&nbsp;==&nbsp;"
                    }
                    if (operatorKind == 1) {
                        txt += "&nbsp;!=&nbsp;"
                    }
                    if (operatorKind == 2) {
                        txt += "&nbsp;&gt;&nbsp;"
                    }
                    if (operatorKind == 3) {
                        txt += "&nbsp;>=&nbsp;"
                    }
                    if (operatorKind == 4) {
                        txt += "&nbsp;&lt;&nbsp;"
                    }
                    if (operatorKind == 5) {
                        txt += "&nbsp;&lt;=&nbsp;"
                    }

                    if (cond.Value !== undefined) {
                        txt += "<b>" + cond.Value + "</b>";
                    } else {
                        txt += "<b>" + globals[cond.Ref] + "</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(" + createNukaLink(cond.Ref) + ")";
                    }


                    cll.innerHTML = txt;

                    if (entry.Conditions.length > 1 && i < entry.Conditions.length - 1) {
                        row = innerTbl.insertRow(innerTbl.rows.length);
                        cll = row.insertCell(0);
                        cll.style.textAlign = "center";
                        cll.style.fontWeight = "bold";

                        if ((cond.Operator & 1) == 0) {
                            cll.innerText = "{ AND }";
                        } else {
                            cll.innerText = "{ OR }";
                        }

                    }
                    i++;
                }
            }

            function buildValueEntry(parent, omiss, maxCols, title, formatter) {
                n = parent.rows.length;
                row = parent.insertRow(n);
                cll = row.insertCell(row.cells.length);
                cll.colSpan = maxCols;
                cll.style.paddingLeft = "60px";

                var innerTbl = document.createElement("table");
                innerTbl.style.borderCollapse = "collapse";
                innerTbl.style.width = "100%";
                cll.appendChild(innerTbl);

                row = innerTbl.insertRow(0);
                cll = row.insertCell(0);

                cll.style.backgroundColor = "C0FFC0";

                var omissSpacer = "<br><span style='margin-left: 20px;'></span>";

                if (omiss.type === "Constant") {
                    cll.innerHTML = title + " (constant): <b>" + formatter(omiss.value) + "</b>";
                }
                else if (omiss.type === "Global") {
                    if (omiss.error === undefined) {
                        cll.innerHTML = title + " (global): <b>" + formatter(omiss.value) + "</b>" + omissSpacer
                            + createNukaLink(omiss.id)
                        ;
                    } else {
                        cll.innerHTML = title + " (global): <b style='color: red;'>" + omiss.error + "</b>" + omissSpacer
                            + createNukaLink(omiss.id)
                        ;
                    }
                }
                else if (omiss.type == "Curve") {
                    if (omiss.error === undefined) {
                        cll.innerHTML = title + " (curve): <b>" + formatter(omiss.value) + "</b>" + omissSpacer
                            + "Table: " + createNukaLink(omiss.id) + omissSpacer
                            + "Global: " + createNukaLink(omiss.g) + " = " + omiss.x
                        ;
                    } else {
                        cll.innerHTML = title + " (curve): <b style='color: red;'>" + omiss.error + "</b>" + omissSpacer
                            + "Table: " + createNukaLink(omiss.id)
                            + "Global: " + createNukaLink(omiss.g)
                        ;
                    }
                }
            }

            function checkConditionsMutual(conditionList) {
                if (conditionList !== undefined) {
                    for (var ce of conditionList) {
                        if (ce.FunctionName === "EditorLocationHasKeyword") {
                            return true;
                        }
                        // TODO expand as necessary
                    }
                }
                return false;
            }

            function compareEntries(curr, prev) {
                return curr.Object === prev.Object 
                       && curr.LVIV === prev.LVIV
                       && curr.LVIG === prev.LVIG
                       && curr.LVOV === prev.LVOV
                       && curr.LVOC === prev.LVOC 
                       && curr.LVOT === prev.LVOT
                       && curr.LVLV === prev.LVLV;
            }
            
            function generateTable(parent, formIDs, index, chanceNode, parentChance) {
                var formID = formIDs[index];

                var lvli = leveledLists[formID];
                var maxCols = 5;

                var n = parent.rows.length;
                var row = parent.insertRow(n);
                var cll = row.insertCell(row.cells.length);
                cll.innerHTML = getGroupID(formID) + ":" + formID + " &lt;" + getEditorID(formID) + "&gt; "
                    + "<a href='https://nukacrypt.com/database/json/" + formID + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>"
                ;
                cll.style.backgroundColor = "#FFCC00";
                cll.style.fontWeight = "bold";
                cll.colSpan = maxCols;

                if (lvli === undefined) {
                    n = parent.rows.length;
                    row = parent.insertRow(n);
                    cll = row.insertCell(row.cells.length);

                    cll.innerText = "Table " + formID + " not found.";
                } else {
                    var omissChanceList = decodeValue(lvli, "LVCV", "LVLG", "LVCT");
                    buildValueEntry(parent, omissChanceList, maxCols, "Omission chance", value => value.toFixed(3) + "%");

                    var maxValueList = decodeValue(lvli, "LVMV", "LVMG", "LVMT");
                    buildValueEntry(parent, maxValueList, maxCols, "Max value", value => value + "");
                    var flagsList = lvli["LVLF"];

                    n = parent.rows.length;
                    row = parent.insertRow(n);
                    cll = row.insertCell(row.cells.length);
                    cll.style.paddingLeft = "60px";
                    cll.colSpan = maxCols;
                    
                    var innerTbl = document.createElement("table");
                    innerTbl.style.borderCollapse = "collapse";
                    innerTbl.style.width = "100%";
                    cll.appendChild(innerTbl);

                    row = innerTbl.insertRow(0);
                    cll = row.insertCell(0);
                    cll.style.backgroundColor = "C0FFC0";
                    var flagsTxt = "Flags (" + flagsList + "): ";

                    if (isFlagsAll(flagsList)) {
                        flagsTxt += "<b>+all</b> "
                    } else {
                        if ((flagsList & 1) != 0) {
                            flagsTxt += "<b>+all-levels</b> "
                        } else {
                            flagsTxt += "<b>+closest-levels</b> "
                        }
                        if (isFlagsEach(flagsList)) {
                            flagsTxt += "<b>+parent-quantity-randomly</b> "
                        } else {
                            flagsTxt += "<b>+one-randomly</b> "
                        }
                    }
                    if ((flagsList & 8) != 0) {
                        flagsTxt += "<b>+u3</b> "
                    }
                    if ((flagsList & 16) != 0) {
                        flagsTxt += "<b>+refspawn</b> "
                    }
                    if ((flagsList & 32) != 0) {
                        flagsTxt += "<b>+u5</b> "
                    }
                    if ((flagsList & 64) != 0) {
                        flagsTxt += "<b>+first-match-all-conditons</b> "
                    }
                    if ((flagsList & 128) != 0) {
                        flagsTxt += "<b>+u7</b> "
                    }


                    cll.innerHTML = flagsTxt;

                    if (lvli.Parents !== undefined) {
                        var n = parent.rows.length;
                        var row = parent.insertRow(n);
                        var cll = row.insertCell(row.cells.length);
                        cll.colSpan = maxCols;
                        cll.innerText = "Referenced from (" + lvli.Parents.length + ")";
                        cll.style.backgroundColor = "#C0FFFF";
                        cll.style.fontWeight = "bold";

                        for (var ref of lvli.Parents) {
                            n = parent.rows.length;
                            row = parent.insertRow(n);

                            cll = row.insertCell(row.cells.length);

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            cll.innerHTML = createListLink(ref, ref);

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            cll.innerHTML = createListLink(ref, getEditorID(ref));

                            cll = row.insertCell(row.cells.length);
                            cll.innerHTML = "<a href='https://nukacrypt.com/database/json/" + ref + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>"

                            cll = row.insertCell(row.cells.length);

                            var btn = document.createElement("button");
                            cll.appendChild(btn);

                            btn.innerText = "Chain";

                            let newFormIDs = [];
                            newFormIDs.push(ref);
                            for (var fi = index; fi < formIDs.length; fi++) {
                                newFormIDs.push(formIDs[fi]);
                            }

                            btn.onclick = function() {
                                showChain(newFormIDs);
                            };
                            if (index > 0 && formIDs[index - 1] == ref) {
                                btn.disabled = true;
                            }
                        }
                    }

                    if (lvli.Conditions !== undefined) {
                        n = parent.rows.length;
                        row = parent.insertRow(n);
                        cll = row.insertCell(row.cells.length);

                        var checkTxt = "";

                        if (evaluateConditions(lvli.Conditions)) {
                            checkTxt = "<span style='color: green; font-weight: bold'>[ &#128077; PASS ]</span>";
                        } else {
                            checkTxt = "<span style='color: red; font-weight: bold'>[ &#10060; FAIL ]</span>";
                        }

                        cll.innerHTML = "Conditions (" + lvli.Conditions.length + ")&nbsp;&nbsp;&nbsp;" + checkTxt;
                        cll.style.backgroundColor = "#C0C0FF";
                        cll.style.fontWeight = "bold";
                        cll.colSpan = maxCols;

                        n = parent.rows.length;
                        row = parent.insertRow(n);
                        cll = row.insertCell(row.cells.length);
                        cll.colSpan = maxCols;
                        var innerTbl = document.createElement("table");
                        innerTbl.style.width = "100%";
                        innerTbl.style.paddingLeft = "20px";
                        cll.appendChild(innerTbl);

                        row = innerTbl.insertRow(0);
                        cll = row.insertCell(0);

                        buildConditionItem(innerTbl, lvli);
                    }
                    if (lvli.Entries !== undefined) {

                        var max = maxValueList.value;

                        n = parent.rows.length;
                        row = parent.insertRow(n);
                        cll = row.insertCell(row.cells.length);

                        cll.innerText = "Entries (" + lvli.Entries.length + ")";
                        cll.style.backgroundColor = "#C0C0FF";
                        cll.style.fontWeight = "bold";
                        cll.colSpan = maxCols;
                        var entries = [];

                        // coalesce same entries
                        if (document.getElementById("Coalesce").checked) {
                            var entriesCopy = JSON.parse(JSON.stringify(lvli.Entries));

                            for (var i = entriesCopy.length - 1; i > 0; i--) {
                                var curr = entriesCopy[i];
                                if (curr.coalesced === undefined) {
                                    curr.coalesced = 1;
                                }
                                if (curr.LVIV === undefined) {
                                    curr.LVIV = 1;
                                }
                                for (var j = i - 1; j >= 0; j--) {
                                    var prev = entriesCopy[j];
                                    if (prev.coalesced === undefined) {
                                        prev.coalesced = 1;
                                    }
                                    if (prev.LVIV === undefined) {
                                        prev.LVIV = 1;
                                    }

                                    if (compareEntries(curr, prev)) {
                                        curr.ignore = true;
                                        prev.coalesced += curr.coalesced;
                                        break;
                                    }
                                }
                            }

                            for (var e of entriesCopy) {
                                if (!e.ignore) {
                                    entries.push(e);
                                }
                            }
                        } else {
                            entries = lvli.Entries;
                        }

                        let settingsLevel = getSettingsValue("MinLevel");
                        let isAllLevel = (lvli.LVLF & 1) != 0;
                        var closestLevel = 0;

                        if (!isAllLevel) {
                            for (var entry of entries) {
                                if (entry.Conditions === undefined || evaluateConditions(entry.Conditions)) {
                                    var lvl = decodeValueOverride(entry, "LVLV", "LVOG", "ZZZZ");
                                    if (lvl <= settingsLevel) {
                                        closestLevel = Math.max(closestLevel, lvl);
                                    }
                                }
                            }
                        }

                        var entryIndex = 0;
                        for (var entry of entries) {
                            n = parent.rows.length;
                            row = parent.insertRow(n);

                            var objectID = entry.Object;
                            var objectEDIDFull = edids[objectID];
                            var objectGroup = "";
                            var objectName = "";
                            if (objectEDIDFull !== undefined) {
                                objectGroup = objectEDIDFull.substring(0, 4);
                                objectName = objectEDIDFull.substring(4);
                            }

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            cll.innerText = objectGroup;

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            if (objectGroup == "LVLI") {
                                cll.innerHTML = createListLink(objectID, objectID);
                            } else {
                                cll.innerText = objectID;
                            }

                            cll = row.insertCell(row.cells.length);
                            cll.style.fontFamily = "monospace";
                            if (objectGroup == "LVLI") {
                                cll.innerHTML = createListLink(objectID, objectName);
                            } else {
                                cll.innerText = objectName;
                            }
                            var qty = decodeValueOverride(entry, "LVIV", "LVIG", "ZZZZ");
                            if (qty > 1) {
                                cll.innerHTML += "&nbsp;<span style='color: blue; font-weight: bold; border: 1px dotted blue;'>&nbsp;x&nbsp;" + qty + "&nbsp;</span>";
                            }

                            cll = row.insertCell(row.cells.length);
                            cll.innerHTML = "<a href='https://nukacrypt.com/database/json/" + objectID + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>"

                            if (objectGroup == "LVLI") {
                                cll = row.insertCell(row.cells.length);
                                var btn = document.createElement("button");
                                btn.innerText = "Open";
                                cll.appendChild(btn);

                                let newFormIDs = [];
                                for (var fi = 0; fi <= index; fi++) {
                                    newFormIDs.push(formIDs[fi]);
                                }
                                newFormIDs.push(objectID);
                                btn.onclick = function() {
                                    currentFormIDs = newFormIDs;
                                    renderTable(newFormIDs);
                                };
                            }

                            var omissChanceEntry = decodeValue(entry, "LVOV", "LVOC", "LVOT");
                            buildValueEntry(parent, omissChanceEntry, maxCols, "Omission chance", value => value.toFixed(3) + "%");
                            var levelEntry = decodeValue(entry, "LVLV", "LVOG", "ZZZZ");
                            if (levelEntry.value > 1 || !isAllLevel) {
                                buildValueEntry(parent, levelEntry, maxCols, "Minimum level", value => {
                                    if (isAllLevel) {
                                        if (value <= settingsLevel) {
                                            return value;
                                        }
                                    }
                                    if (value === closestLevel) {
                                        return value;
                                    }
                                    
                                    return value + " [ &#10060; FAIL ]";
                                });
                            }

                            if (entry.LVIG !== undefined) {
                                var qtyEntry = decodeValue(entry, "LVIV", "LVIG", "ZZZZ");
                                buildValueEntry(parent, qtyEntry, maxCols, "Quantity", value => value);
                            }

                            buildConditionEntry(parent, entry, maxCols);

                            n = parent.rows.length;
                            row = parent.insertRow(n);
                            cll = row.insertCell(row.cells.length);
                            cll.colSpan = 2;

                            cll = row.insertCell(row.cells.length);
                            cll.colSpan = Math.max(1, maxCols - 3);


                            var itemNode = chanceNode.items[entryIndex];
                            var entrySelfChance = itemNode.chance;
                            var entryChance = 0;
                            var coalesced = entry.coalesced !== undefined ? entry.coalesced : 1;

                            var chanceTable = document.createElement("table");
                            cll.appendChild(chanceTable);
                            chanceTable.style.width = "100%";

                            row = chanceTable.insertRow(0);
                            cll = row.insertCell(0)
                            cll.style.fontWeight = "bold";
                            cll.innerText = "Drop chance (cumulative)";

                            cll = row.insertCell(1)
                            cll.style.fontWeight = "bold";
                            if (entrySelfChance !== undefined) {
                                cll.style.textAlign = "right";
                                entryChance = entrySelfChance * parentChance * coalesced;
                                cll.innerText = (entryChance * 100.0).toFixed(3) + "%";
                            } else {
                                cll.style.textAlign = "center";
                                cll.innerText = "N/A";
                            }
                            cll.style.border = "1px dotted red";
                            cll.style.color = "red";

                            if (objectGroup == "LVLI" && formIDs.length > index + 1 && formIDs[index + 1] == objectID) {
                                n = parent.rows.length;
                                row = parent.insertRow(n);

                                cll = row.insertCell(row.cells.length);
                                cll.colSpan = maxCols;
                                cll.style.paddingLeft = "40px";
                                cll.style.border = "1px solid black";

                                var innerTable = document.createElement("table");
                                cll.appendChild(innerTable);

                                var cascadeChance = entryChance;
                                if (itemNode.apriori !== undefined) {
                                    cascadeChance = parentChance * itemNode.apriori;
                                }
                                generateTable(innerTable, formIDs, index + 1, chanceNode.items[entryIndex].sublist, cascadeChance);

                                btn.innerText = "Close";
                                let closeFormIDs = formIDs.slice(0, index + 1);
                                btn.onclick = function() {
                                    currentFormIDs = closeFormIDs;
                                    renderTable(closeFormIDs);
                                };
                            }

                            entryIndex++;
                        }
                    }
                }
            }

            // string key (function name or FormID) to its HTML control
            var settingsMap = new Map();

            var settingsCheckboxes = document.getElementById("settingsCheckboxes");
            var settingsComboboxes = document.getElementById("settingsComboboxes");
            var settingsGlobals = document.getElementById("settingsGlobals");

            function gatherSettings(rootFormID) {
                settingsCheckboxes.innerHTML = "";
                settingsComboboxes.innerHTML = "";
                settingsGlobals.innerHTML = "";
                settingsMap.clear();

                var lvli = leveledLists[rootFormID];

                appendLevelInput();
                gatherSettingsEntry(lvli);

                for (var input of settingsMap.values()) {
                    input.oninput = function() {
                        updateChances(currentFormIDs);
                    };
                }
            }

            var propertyNames = {
                "LVLV": "Minimum level"
            }

            function appendTextBox(node, key, isRef) {
                
                var id = isRef ? node[key] : key;
                if (settingsMap.get(id) != null) {
                    return;
                }

                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                if (isRef) {
                    span.innerHTML = createNukaLink(node[key]) + "&nbsp;&nbsp;";
                } else {
                    span.innerHTML = (propertyNames[key] !== undefined ? propertyNames[key] : key)  + "&nbsp;&nbsp;";
                }

                var input = document.createElement("input");
                span.appendChild(input);
                input.type = "text";
                input.style.width = "50px";
                input.id = isRef ? key + "_" + node[key] : key;
                input.value = isRef ? globals[node[key]] : node[key];

                var span2 = document.createElement("span");
                span.appendChild(span2);
                span2.innerHTML = "&nbsp;(" + input.value + ")<br>";

                settingsMap.set(id, input);
            }

            function appendCheckBox(functionName, value) {
                var key = functionName + "_" + value;
                var input = settingsMap.get(key);
                if (input == null) {
                    var span = document.createElement("span");
                    settingsCheckboxes.appendChild(span);

                    input = document.createElement("input");
                    span.appendChild(input);
                    input.type = "checkbox";
                    input.id = key;

                    var lbl = document.createElement("label");
                    span.appendChild(lbl);
                    lbl.htmlFor = key;
                    lbl.innerHTML = "&nbsp;" + functionName + ":&nbsp;";

                    var span2 = document.createElement("span");
                    span.appendChild(span2);
                    span2.innerHTML = createNukaLink(value) + "<br>";

                    settingsMap.set(key, input);
                }
            }

            function appendComboBox(functionName, value) {

                var input = settingsMap.get(functionName);
                if (input == null) {

                    var span = document.createElement("span");
                    settingsComboboxes.appendChild(span);
                    span.innerHTML = functionName + "&nbsp;&nbsp;"
                    
                    input = document.createElement("select");
                    span.appendChild(input);

                    var defaultOp = document.createElement("option");
                    input.add(defaultOp);
                    defaultOp.text = "N/A";
                    defaultOp.value = "";
                    defaultOp.selected = true;

                    var span2 = document.createElement("span");
                    span.appendChild(span2);
                    span2.innerHTML = "&nbsp;&nbsp;";

                    var a = document.createElement("a");
                    span.appendChild(a);
                    a.innerHTML = "&#x2622;"
                    a.href = "#";

                    let finput = input;
                    a.onclick = function() {
                        var entry = finput.options[finput.selectedIndex].value;
                        if (entry !== "") {
                            window.open("https://nukacrypt.com/database/json/" + entry, "_blank");
                        }
                        return false;
                    };

                    settingsMap.set(functionName, input);
                }

                for (var op of input.options) {
                    if (op.value === value) {
                        return;
                    }
                }

                var opt = document.createElement("option");
                input.add(opt);
                opt.text = getGroupID(value) + ":" + value + " <" + getEditorID(value) + ">";
                opt.value = value;
            }

            function appendLevelInput() {
                
                var span = document.createElement("span");
                settingsGlobals.appendChild(span);
                span.innerHTML = "Player/Target level&nbsp;&nbsp;";

                var input = document.createElement("input");
                span.appendChild(input);
                input.type = "number";
                input.min = 1;
                input.style.width = "80px";
                input.id = "MinLevel";
                input.value = 1;

                var span2 = document.createElement("br");
                span.appendChild(span2);

                settingsMap.set("MinLevel", input);
            }

            function gatherSettingsEntry(node) {

                // omission chance global
                if (node.LVLG !== undefined) {
                    appendTextBox(node, "LVLG", true);
                }
                // entry omission chance global
                if (node.LVOC !== undefined) {
                    appendTextBox(node, "LVOC", true);
                }

                // entry min level global
                if (node.LVOG !== undefined) {
                    appendTextBox(node, "LVOG", true);
                }
                // max value global
                if (node.LVMG !== undefined) {
                    appendTextBox(node, "LVMG", true);
                }

                // functions
                if (node.FunctionName !== undefined) {
                    var fn = node.FunctionName;
                    if (fn === "GetIsInRegion") {
                        appendComboBox(fn, node.Param1Ref);
                    }
                    if (fn === "HasLearnedRecipe"
                        || fn === "EditorLocationHasKeyword"
                        || fn === "GetQuestCompleted"
                        ) {
                        appendCheckBox(fn, node.Param1Ref);
                    }
                    if (fn === "GetGlobalValue") {
                        appendTextBox(node, "Param1Ref", true);
                    }
                    if (node.Ref !== undefined) {
                        appendTextBox(node.ref, "Ref", true);
                    }
                }

                if (node.Object !== undefined) {
                    var sublist = leveledLists[node.Object];
                    if (sublist !== undefined) {
                        gatherSettingsEntry(sublist);
                    }
                }

                if (node.Conditions !== undefined) {
                    for (var entry of node.Conditions) {
                        gatherSettingsEntry(entry);
                    }
                }

                if (node.Entries !== undefined) {
                    for (var entry of node.Entries) {
                        gatherSettingsEntry(entry);
                    }
                }
            }

            // key is and index path, value is a record { chance: 0.0, nochance: 0.0 }
            var chanceTree = {};

            function createChanceNode(id) {
                return {
                    formID: id,
                    conditionMatch: true, // turns false if the level requirements or conditions are not met
                    levelMatch: true,
                    chanceNone: 0, // the node's default chance none value [0..1]
                    flags: 0, // the node's flags
                    max: 0, // the node's max value extracted
                    presentCount: 0,
                    hasSubLists: false,
                    items: []
                };
            }

            function calculateChances(rootFormID) {
                // build a tree and apply condition parameters
                
                chanceTree = createChanceNode(rootFormID);

                recurseForms(chanceTree);

                // walk the tree
                recurseTree(chanceTree);
            }

            function isFlagsAll(flags) {
                return (flags & 4) != 0;
            }
            function isFlagsEach(flags) {
                return (flags & 2) != 0;
            }

            // returns undefined for an unsupported setup or a record { emptyChance: float, [items: array] }
            function processLeafNode(node, isAll, isEach, presentEntries, neverEmpty, hasAlwaysPresentEntry) {
                var baseChance = 1 - node.chanceNone;
                // only leaf nodes
                if (isAll) {
                    // all items
                    if (node.max == 0) {
                        var nodeChanceEmpty = 1;

                        for (var entry of presentEntries) {
                            var entrySelfChance = (1 - entry.chanceNone) * baseChance;

                            entry.chance = entrySelfChance;

                            nodeChanceEmpty *= (1 - entrySelfChance);
                        }

                        return { emptyChance: nodeChanceEmpty };
                    }
                    // first present
                    if (node.max == 1) {
                        var nodeChanceRemaining = 1;

                        for (var entry of presentEntries) {
                            var entrySelfChance = (1 - entry.chanceNone) * baseChance;

                            entry.chance = nodeChanceRemaining * entrySelfChance;

                            nodeChanceRemaining *= (1 - entrySelfChance);
                        }

                        return { emptyChance: nodeChanceRemaining };
                    }
                } else {
                    // pick one entry at random
                    // with foreach and parent.quantity > 1, it means reroll quantity times
                    // let the parent calculate the multi-roll probabilities

                    // all entries have chanceNone == 0 thus this is a simple 1/N random pick
                    if (neverEmpty) {
                        var uniform = baseChance / presentEntries.length;
                        for (var entry of presentEntries) {
                            entry.chance = uniform;
                        }

                        return { emptyChance: node.chanceNone, items: presentEntries };
                    } else {
                        // otherwise it is a 2^N combinational formula
                        // we calculate it expliticty for sorter lists as it takes exponential time
                        if (presentEntries.length <= formulaLimit) {
                            // prepare sum for entries
                            for (var entry of presentEntries) {
                                entry.chance = 0;
                            }

                            var nodeChanceEmpty = 1;

                            // use exact formulation
                            var bitMap = 1 << presentEntries.length;

                            for (var i = 0; i < bitMap; i++) {
                                var product = 1;
                                var nonzeroCount = 0;

                                for (var j = 0; j < presentEntries.length; j++) {
                                    var entry = presentEntries[j];
                                    var bit = 1 << j;
                                    if ((i & bit) == 0) {
                                        product *= entry.chanceNone;
                                    } else {
                                        nonzeroCount++;
                                        product *= 1 - entry.chanceNone;
                                    }
                                }

                                if (nonzeroCount == 0) {
                                    nodeChanceEmpty = product;
                                } else {
                                    product /= nonzeroCount;
                                    for (var j = 0; j < presentEntries.length; j++) {
                                        var entry = presentEntries[j];
                                        var bit = 1 << j;
                                        if ((i & bit) != 0) {
                                            entry.chance += product;
                                        }
                                    }
                                }
                            }

                            for (var entry of presentEntries) {
                                entry.chance *= baseChance;
                            }

                            return { emptyChance: nodeChanceEmpty * baseChance + node.chanceNone, items: presentEntries };
                        } else {
                            // otherwise we use a monte-carlo simulation of the list itself to approximate
                            // chance acts as a counter
                            for (var entry of presentEntries) {
                                entry.chance = 0;
                            }

                            var emptyList = 0;

                            // use monte-carlo
                            for (var i = 0; i < monteCarloCount; i++) {
                                var selection = [];
                                for (var entry of presentEntries) {
                                    if (entry.chanceNone <= Math.random()) {
                                        selection.push(entry);
                                    }
                                }
                                if (selection.length == 0) {
                                    emptyList++;
                                } else {
                                    var idx = selection.length * Math.random();
                                    presentEntries[idx].chance++;
                                }
                            }


                            // do the average over all the runs
                            for (var entry of presentEntries) {
                                entry.chance = baseChance * entry.chance / monteCarloCount;
                            }

                            var noneChanceEmpty;
                            if (hasAlwaysPresentEntry) {
                                nodeChanceEmpty = 0.0;
                            } else {
                                noneChanceEmpty = emptyList / monteCarloCount;
                            }

                            return { emptyChance: nodeChanceEmpty * baseChance + node.chanceNone, items: presentEntries };
                        }
                    }
                }

                return undefined;
            }

            // returns undefined for an unsupported setup or a record { emptyChance: float, [items: array] }
            function processMixedNode(node, isAll, isEach, presentEntries, neverEmpty, hasAlwaysPresentEntry) {
                var baseChance = 1 - node.chanceNone;
                if (isAll) {
                    if (node.max == 0) {
                        var nodeChanceEmpty = 1;

                        for (var entry of presentEntries) {
                            if (entry.sublist === undefined) {
                                var entrySelfChance = 1 - entry.chanceNone;

                                entry.chance = entrySelfChance * baseChance;

                                nodeChanceEmpty *= (1 - entrySelfChance);
                            } else {
                                var subchances = recurseTree(entry.sublist);
                                if (subchances !== undefined) {
                                    var entrySelfChance;

                                    if (entry.quantity > 1 && isFlagsEach(entry.sublist.flags)) {
                                        // if the sublist produced items and we should reroll the entire list quantity times
                                        entrySelfChance = (1 - entry.chanceNone) * (1 - Math.pow(subchances.emptyChance, entry.quantity));
                                        // ??? update subentry chances to reflect at-least-once chance
                                        for (var subEntry of subchances.items) {
                                            subEntry.chance = 1 - Math.pow(1 - subEntry.chance, entry.quantity);
                                            // recurse ???
                                        }
                                    } else {
                                        // the sublist is either run-once, all, or the reroll quantity is 1 anyway
                                        
                                        entrySelfChance = (1 - entry.chanceNone) * (1 - subchances.emptyChance);

                                    }
                                    entry.chance = entrySelfChance * baseChance;

                                    nodeChanceEmpty *= (1 - entrySelfChance);
                                }
                            }
                        }

                        return { emptyChance: nodeChanceEmpty * baseChance + node.chanceNone };
                    }
                    if (node.max == 1) {
                        var nodeChanceRemaining = 1;

                        for (var entry of presentEntries) {
                            if (entry.sublist === undefined) {
                                var entrySelfChance = nodeChanceRemaining * (1 - entry.chanceNone);

                                entry.chance = entrySelfChance * baseChance;

                                nodeChanceRemaining *= (1 - entrySelfChance);
                            } else {
                                var subchances = recurseTree(entry.sublist);
                                if (subchances !== undefined) {
                                    var entrySelfChance;
                                    if (entry.quantity > 1 && isFlagsEach(entry.sublist.flags)) {
                                        // if the sublist produced items and we should reroll the entire list quantity times
                                        // if the sublist produced items and we should reroll the entire list quantity times
                                        entrySelfChance = (1 - entry.chanceNone) * (1 - Math.pow(subchances.emptyChance, entry.quantity));
                                        // ??? update subentry chances to reflect at-least-once chance
                                        for (var subEntry of subchances.items) {
                                            subEntry.chance = 1 - Math.pow(1 - subEntry.chance, entry.quantity);
                                            // recurse ???
                                        }
                                    } else {
                                        // the sublist is either run-once, all, or the reroll quantity is 1 anyway
                                        
                                        entrySelfChance = (1 - entry.chanceNone) * (1 - subchances.emptyChance);
                                    }
                                    entry.chance = nodeChanceRemaining * entrySelfChance * baseChance;
                                    if (subchances.emptyChance >= epsilon) {
                                        entry.apriori = nodeChanceRemaining * (1 - entry.chanceNone);
                                    }

                                    nodeChanceRemaining *= (1 - entrySelfChance);
                                }
                            }
                        }

                        return { emptyChance: nodeChanceRemaining * baseChance + node.chanceNone };
                    }
                } else {
                    // pick one randomly
                    if (neverEmpty) {
                        // loop over each entry to see if they by themselves could return emptyChance == 0
                        var subsNeverEmpty = true;
                        for (var entry of presentEntries) {
                            if (entry.sublist !== undefined) {
                                var subchances = recurseTree(entry.sublist);
                                if (subchances !== undefined) {
                                    if (subchances.emptyChance >= epsilon) {
                                        subsNeverEmpty = false;
                                        break;
                                    }
                                } 
                            }
                        }

                        if (subsNeverEmpty) {
                            var uniform = baseChance / presentEntries.length;
                            for (var entry of presentEntries) {
                                entry.chance = uniform;
                            }

                            return { emptyChance: node.chanceNone, items: presentEntries };
                        }
                    }
                    // otherwise, we have to use the 2^N formula

                    for (var entry of presentEntries) {
                        entry.chance = 0;

                        if (entry.sublist !== undefined) {
                            var subchances = recurseTree(entry.sublist);
                            if (subchances !== undefined) {
                                if (entry.quantity > 1 && isFlagsEach(entry.sublist.flags)) {
                                    // if the sublist produced items and we should reroll the entire list quantity times
                                    // if the sublist produced items and we should reroll the entire list quantity times
                                    entry.selfChance = (1 - Math.pow(subchances.emptyChance, entry.quantity));
                                    // ??? update subentry chances to reflect at-least-once chance
                                    for (var subEntry of subchances.items) {
                                        subEntry.chance = 1 - Math.pow(1 - subEntry.chance, entry.quantity);
                                        // recurse ???
                                    }
                                } else {
                                    // the sublist is either run-once, all, or the reroll quantity is 1 anyway
                                    
                                    entry.selfChance = (1 - subchances.emptyChance);
                                }
                            } else {
                                entry.selfChance = 0;
                            }
                        } else {
                            entry.selfChance = 1;
                        }
                    }

                    // we calculate it expliticty for sorter lists as it takes exponential time
                    if (presentEntries.length <= formulaLimit) {
                        var nodeChanceEmpty = 1;

                        // use exact formulation
                        var bitMap = 1 << presentEntries.length;

                        for (var i = 0; i < bitMap; i++) {
                            var product = 1;
                            var nonzeroCount = 0;

                            for (var j = 0; j < presentEntries.length; j++) {
                                var entry = presentEntries[j];
                                var selfChance = (1 - entry.chanceNone) * entry.selfChance;
                                var bit = 1 << j;
                                if ((i & bit) == 0) {
                                    product *= 1 - selfChance;
                                } else {
                                    nonzeroCount++;
                                    product *= selfChance;
                                }
                            }

                            if (nonzeroCount == 0) {
                                nodeChanceEmpty = product;
                            } else {
                                product /= nonzeroCount;
                                for (var j = 0; j < presentEntries.length; j++) {
                                    var entry = presentEntries[j];
                                    var bit = 1 << j;
                                    if ((i & bit) != 0) {
                                        entry.chance += product;
                                    }
                                }
                            }
                        }

                        for (var entry of presentEntries) {
                            entry.chance *= baseChance;
                        }

                        return { emptyChance: nodeChanceEmpty * baseChance + node.chanceNone, items: presentEntries };
                    } else {
                        // otherwise we use a monte-carlo simulation of the list itself to approximate
                        // chance acts as a counter
                        
                        var emptyList = 0;

                        // use monte-carlo
                        for (var i = 0; i < monteCarloCount; i++) {
                            var selection = [];
                            for (var entry of presentEntries) {
                                if (entry.chanceNone <= Math.random()) {
                                    if (entry.selfChance === undefined || entry.selfChance > Math.random()) {
                                        selection.push(entry);
                                    }
                                }
                            }
                            if (selection.length == 0) {
                                emptyList++;
                            } else {
                                var idx = selection.length * Math.random();
                                presentEntries[idx].chance++;
                            }
                        }


                        // do the average over all the runs
                        for (var entry of presentEntries) {
                            entry.chance = baseChance * entry.chance / monteCarloCount;
                        }

                        var noneChanceEmpty;
                        if (hasAlwaysPresentEntry) {
                            nodeChanceEmpty = 0.0;
                        } else {
                            noneChanceEmpty = emptyList / monteCarloCount;
                        }

                        return { emptyChance: nodeChanceEmpty * baseChance + node.chanceNone, items: presentEntries };
                    }
                }
                return undefined;
            }

            // returns undefined for an unsupported setup or a record { emptyChance: float, [items: array] }
            function recurseTree(node) {
                if (!node.conditionMatch) {
                    return undefined;
                }
                var isAll = isFlagsAll(node.flags);
                var isEach = isFlagsEach(node.flags);

                var presentEntries = [];
                var neverEmpty = true;
                var hasAlwaysPresentEntry = false;
                for (var entry of node.items) {
                    if (entry.levelMatch && entry.conditionMatch) {
                        presentEntries.push(entry);
                        if (entry.chanceNone > 0) {
                            neverEmpty = false;
                        } else {
                            hasAlwaysPresentEntry = true;
                        }
                    }
                }

                if (node.hasSubLists) {
                    return processMixedNode(node, isAll, isEach, presentEntries, neverEmpty, hasAlwaysPresentEntry);
                }
                return processLeafNode(node, isAll, isEach, presentEntries, neverEmpty, hasAlwaysPresentEntry);
            }

            function getSettingsValue(key) {
                var input = settingsMap.get(key);
                if (input !== undefined) {
                    if (input.selectedIndex !== undefined) {
                        return input.options[input.selectedIndex].value;
                    }
                    else if (input.type !== undefined) {
                        if (input.type === "checkbox") {
                            return input.checked ? 1 : 0;
                        }
                        return parseFloat(input.value);
                    }
                    return 0;
                }
                return undefined;
            }

            function decodeValueOverride(node, defaultKey, globalKey, curveKey) {
                var globalFormID = node[globalKey];
                var curveFormID = node[curveKey];

                if (curveFormID !== undefined) {
                    var x = getSettingsValue(globalFormID);
                    if (x === undefined) {
                        x = globals[globalFormID];
                    }
                    return interpolate(curves[curveFormID], x);
                }
                else if (globalFormID !== undefined) {
                    var x = getSettingsValue(globalFormID);
                    if (x === undefined) {
                        x = globals[globalFormID];
                    }
                    return x;
                }
                var defaultValue = node[defaultKey];
                return defaultValue !== undefined ? defaultValue : 0;
            }

            function evaluateConditions(Conditions) {

                var logicOutcome = false;

                var index = 0;
                for (var cond of Conditions) {

                    var compareWith = cond.Value;
                    // compare with global instead?
                    if (compareWith === undefined) {
                        compareWith = getSettingsValue(cond.Ref);
                    }

                    var fn = cond.FunctionName;

                    var functionResult = "";
                    if (fn === "GetIsInRegion") {
                        var selectOption = getSettingsValue(fn);
                        functionResult = selectOption == cond.Param1Ref;
                    }
                    else if (fn === "HasLearnedRecipe"
                            || fn === "EditorLocationHasKeyword"
                            || fn === "GetQuestCompleted"
                        ) {
                        functionResult = getSettingsValue(fn + "_" + cond.Param1Ref);
                    }
                    else if (fn === "GetLevel") {
                        functionResult = getSettingsValue("MinLevel");
                    }
                    else if (fn === "GetGlobalValue") {
                        functionResult = getSettingsValue(cond.Param1Ref);
                    }

                    var op = (cond.Operator & 0xFF) >> 5;
                    
                    var evaluation = false;

                    if (typeof(functionResult) === "string") {
                        functionResult = parseFloat(functionResult.replace(',', '.'));
                    }
                    if (typeof(compareWith) === "string") {
                        compareWith = parseFloat(compareWith.replace(',', '.'));
                    }

                    if (op == 0) {
                        evaluation = functionResult == compareWith;
                    }
                    else if (op == 1) {
                        evaluation = functionResult != compareWith;
                    }
                    else if (op == 2) {
                        evaluation = functionResult > compareWith;
                    }
                    else if (op == 3) {
                        evaluation = functionResult >= compareWith;
                    }
                    else if (op == 4) {
                        evaluation = functionResult < compareWith;
                    }
                    else if (op == 5) {
                        evaluation = functionResult <= compareWith;
                    }

                    if (index == 0) {
                        logicOutcome = evaluation;
                    } else {
                        var logicAnd = (cond.Operator & 1) == 0;
                        if (logicAnd) {
                            logicOutcome &= evaluation;
                        } else {
                            logicOutcome |= evaluation;
                        }
                    }

                    index++;
                }
                return logicOutcome;
            }

            function recurseForms(node) {
                var lvli = leveledLists[node.formID];

                node.flags = lvli.LVLF;
                node.max = decodeValueOverride(lvli, "LVMV", "LVMG", "LVMT");
                node.chanceNone = decodeValueOverride(lvli, "LVCV", "LVLG", "LVCT") / 100.0;

                if (lvli.Conditions !== undefined) {
                    node.conditionMatch = evaluateConditions(lvli.Conditions);
                }

                var isClosestLevel = (lvli.LVLF & 1) == 0;

                if (lvli.Entries !== undefined) {
                    let settingsLevel = getSettingsValue("MinLevel");

                    var closestLevel = 0;

                    var entryIndex = 0;
                    for (var entry of lvli.Entries) {

                        var entryNode = {
                            formID: entry.Object,
                            conditionMatch: true,
                            levelMatch: true,
                            chanceNone: 0, // the node's default chance none value [0..1]
                            level: 0,
                            quantity: 1,
                            index: entryIndex,
                            sublist: undefined
                        };

                        node.items.push(entryNode);
                        entryNode.chanceNone = decodeValueOverride(entry, "LVOV", "LVOC", "LVOT") / 100.0;
                        entryNode.level = decodeValueOverride(entry, "LVLV", "LVOG", "ZZZZ");
                        entryNode.quantity = decodeValueOverride(entry, "LVIV", "LVIG", "ZZZZ");
                        
                        if (entry.Conditions !== undefined) {
                            entryNode.conditionMatch = evaluateConditions(entry.Conditions);
                        }

                        if (isClosestLevel && entryNode.conditionMatch && entryNode.level <= settingsLevel) {
                            closestLevel = Math.max(closestLevel, entryNode.level);
                        }

                        if (getGroupID(entry.Object) === "LVLI") {
                            node.hasSubLists = true;
                            entryNode.sublist = createChanceNode(entry.Object);
                            recurseForms(entryNode.sublist);
                        }

                        entryIndex++;
                    }

                    for (var n of node.items) {
                        if (isClosestLevel) {
                            n.levelMatch = n.level == closestLevel;
                        } else {
                            n.levelMatch = n.level <= settingsLevel;
                        }
                        if (n.conditionMatch && n.levelMatch) {
                            node.presentCount++;
                        }
                    }
                }
            }

            function showChain(formIDs) {
                currentFormIDs = formIDs;

                gatherSettings(formIDs[0]);

                updateChances(formIDs);
            }

            function updateChances(formIDs) {
                calculateChances(formIDs[0]);

                renderTable(formIDs);
            }

            function renderTable(formIDs) {
                var mainTable = document.getElementById("listtable");

                clear(mainTable);

                generateTable(mainTable, formIDs, 0, chanceTree, 1);

                var tableLink = document.getElementById("tableLink");

                var patchSel = document.getElementById("versionselect");
                var patch = patchSel.options[patchSel.selectedIndex].value;

                tableLink.href = "?patch=" + patch + "&formids=" + encodeURIComponent(formIDs.join("-"));
                tableLink.style.display = "inline";

                var coalesce = document.getElementById("Coalesce");
                let fids = formIDs;
                coalesce.oninput = function() {
                    renderTable(fids);
                };
            }

            function clear(table) {
                for (var i = table.rows.length - 1; i >= 0; i--) {
                    table.deleteRow(i);
                }
            }

            function showList(formID) {
                showChain([formID]);
            }

            function createIgnoreRow(resultsTable, ignoreFlag) {
                var n = resultsTable.rows.length;
                var row = resultsTable.insertRow(n);
                var cll = row.insertCell(row.cells.length);
                cll.colSpan = 3;
                cll.style.borderTop = "1px solid black";
                cll.style.textAlign = "center";
                cll.style.fontStyle = "italic";
                var txt = [];
                if ((ignoreFlag & 1) != 0) {
                    txt.push("Atom Shop");
                }
                if ((ignoreFlag & 2) != 0) {
                    txt.push("Cut content");
                }
                if ((ignoreFlag & 4) != 0) {
                    txt.push("Debug content");
                }
                cll.innerText = "Entries found but ignored due to options: " + txt.join(", ");
            }

            function searchLists() {
                var textField = document.getElementById("listsearchterm");
                var regexps = parseSearchText(textField.value);

                var resultsTable = document.getElementById("searchresults");

                clear(resultsTable);

                var includeATX = document.getElementById("IncludeATX").checked;
                var includeCut = document.getElementById("IncludeCut").checked;
                var includeDebug = document.getElementById("IncludeDebug").checked;

                var ignoreFlag = 0;

                var foundList = [];

                for (var formID in leveledLists) {
                    var editorId = getEditorID(formID).toLowerCase();
                    var match = false;

                    var nozeroFormID = formID.replace(/^0+/, "").toLowerCase();
                    while (nozeroFormID.charAt(0) == "0") {
                        nozeroFormID = nozeroFormID.substring(1);
                    }
                    
                    for (var regexp of regexps) {
                        if (regexp.test(nozeroFormID)) {
                            match = true;
                            break;
                        }
                        if (regexp.test(editorId)) {
                            match = true;
                            break;
                        }
                    }

                    if (match) {
                        if (!includeATX && editorId.startsWith("atx_")) {
                            ignoreFlag = ignoreFlag | 1;
                            continue;
                        }
                        if (!includeCut && (editorId.startsWith("zzz") || editorId.includes("cut"))) {
                            ignoreFlag = ignoreFlag | 2;
                            continue;
                        }
                        if (!includeDebug && (editorId.includes("debug") || editorId.includes("test"))) {
                            ignoreFlag = ignoreFlag | 4;
                            continue;
                        }

                        foundList.push(formID);
                    }
                }

                generateSearchResults(resultsTable, foundList, ignoreFlag);
            }

            function generateSearchResults(resultsTable, foundList, ignoreFlag) {

                if (document.getElementById("SortByEditorID").checked) {
                    foundList.sort((a, b) => {
                        var e1 = getEditorID(a);
                        var e2 = getEditorID(b);
                        return e1.localeCompare(e2);
                    });
                }

                for (var formID of foundList) {
                    var n = resultsTable.rows.length;
                    var row = resultsTable.insertRow(n);

                    if (n % 2 != 0) {
                        row.style.backgroundColor = "#E0E0E0";
                    }

                    /*
                    var cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerText = getGroupID(formID);
                    */
                    
                    cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerHTML = createListLink(formID, formID);

                    cll = row.insertCell(row.cells.length);
                    cll.style.fontFamily = "monospace";
                    cll.innerHTML = createListLink(formID, getEditorID(formID));

                    cll = row.insertCell(row.cells.length);
                    cll.innerHTML = "<a href='https://nukacrypt.com/database/json/" + formID + "' target='_blank' title='See Nukacrypt data.'>&#x2622;</a>"
                }

                if (ignoreFlag != 0) {
                    createIgnoreRow(resultsTable, ignoreFlag);
                } else
                if (resultsTable.rows.length == 0) {
                    var n = resultsTable.rows.length;
                    var row = resultsTable.insertRow(n);
                    var cll = row.insertCell(row.cells.length);

                    cll.innerText = "No leveled lists found.";
                }
            }

            function searchItems() {
                var textField = document.getElementById("itemsearchterm");
                var regexps = parseSearchText(textField.value);

                var resultsTable = document.getElementById("searchresults");

                clear(resultsTable);

                var includeATX = document.getElementById("IncludeATX").checked;
                var includeCut = document.getElementById("IncludeCut").checked;
                var includeDebug = document.getElementById("IncludeDebug").checked;

                var ignoreFlag = 0;

                var foundList = [];

                for (var formID in leveledLists) {
                    var editorId = getEditorID(formID).toLowerCase();
                    var lvli = leveledLists[formID];

                    var match = false;

                    if (lvli.Entries === undefined) {
                        continue;
                    }

                    outer:
                    for (var listEntries of lvli.Entries) {
                        var entryId = listEntries.Object;
                        var nozeroEntryID = entryId.replace(/^0+/, "").toLowerCase();
                        var entryEditorId = getEditorID(entryId).toLowerCase()

                        for (var regexp of regexps) {
                            if (regexp.test(nozeroEntryID)) {
                                match = true;
                                break outer;
                            }
                            if (regexp.test(entryEditorId)) {
                                match = true;
                                break outer;
                            }
                        }
                    }

                    if (match) {
                        if (!includeATX && editorId.startsWith("atx_")) {
                            ignoreFlag = ignoreFlag | 1;
                            continue;
                        }
                        if (!includeCut && (editorId.startsWith("zzz") || editorId.includes("cut"))) {
                            ignoreFlag = ignoreFlag | 2;
                            continue;
                        }
                        if (!includeDebug && (editorId.includes("debug") || editorId.includes("test"))) {
                            ignoreFlag = ignoreFlag | 4;
                            continue;
                        }

                        foundList.push(formID);
                    }
                }

                generateSearchResults(resultsTable, foundList, ignoreFlag);
            }

            document.getElementById("listsearchbtn").onclick = searchLists;
            document.getElementById("itemsearchbtn").onclick = searchItems;

            document.getElementById("listsearchterm").onkeydown = function(evt) {
                if (evt.keyCode == 13) {
                    searchLists();
                }
            };
            document.getElementById("itemsearchterm").onkeydown = function(evt) {
                if (evt.keyCode == 13) {
                    searchItems();
                }
            };

            document.getElementById("clearResults").onclick = function() {
                clear(document.getElementById("searchresults"));
            };

            var settingsToggle = document.getElementById("settingstoggle");
            settingsToggle.onclick = function() {
                var settingsTable = document.getElementById("settings");
                if (settingsTable.style.display !== "none") {
                    settingsTable.style.display = "none";
                    settingsToggle.innerHTML = "&nbsp;+&nbsp;"
                } else {
                    settingsTable.style.display = "table";
                    settingsToggle.innerHTML = "&nbsp;-&nbsp;"
                }
            };

            var q = location.search;

            if (q.includes("patch=")) {
                var idx = q.indexOf("patch=");
                var jdx = q.indexOf("&", idx + 1);
                if (jdx < 0) {
                    jdx = q.length;
                }
                var patch = q.substring(6, jdx);
                var versionSelect = document.getElementById("versionselect");
                for (var i = 0; i < versionSelect.options.length; i++) {
                    var opt = versionSelect.options[i];
                    if (opt.value === patch) {
                        opt.selected = true;
                        break;
                    }
                }         
            }
            doLoad();
        </script>
    </body>
</html>